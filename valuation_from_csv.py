#!/usr/bin/env python3
"""
CSV-Based Options Valuation and Analysis Engine
=============================================

This script processes previously scraped NSE options data from CSV files to perform comprehensive
valuation analysis. It's designed to work with the output files generated by nse_scraper.py.

Key Features:
- Processes CSV files containing NSE options data
- Automatically finds the latest CSV file if no specific file is specified
- Calculates theoretical prices using Black-Scholes model
- Computes all Greeks (Delta, Gamma, Theta, Vega, Rho)
- Performs advanced valuation analysis with confidence scoring
- Handles large datasets efficiently with batch processing
- Generates comprehensive analysis reports

Input Requirements:
CSV must contain these columns:
- Ticker, Expiration, Strike, Type (call/put)
- LTP (Last Traded Price), IV (Implied Volatility)
- Bid, Ask, Spot (underlying price), T_years (time to expiry)

Processing Pipeline:
1. CSV validation and column checking
2. Data quality assessment and filtering
3. Greeks calculation for each valid option
4. Theoretical price calculation
5. Advanced valuation analysis considering:
   * Moneyness effects
   * Time decay factors
   * Volatility environment
   * Bid-ask spread liquidity
6. Results compilation and export

Output:
- Enhanced CSV with calculated fields:
  * Theoretical_Price: Black-Scholes theoretical value
  * Valuation_Rating: Undervalued/Overvalued assessment
  * Pct_Difference: Percentage difference from theoretical
  * Confidence: Confidence level in valuation
  * All Greeks: Delta, Gamma, Theta, Vega, Rho
- Comprehensive summary statistics
- Data quality metrics

Usage:
    python valuation_from_csv.py
    # Enter CSV filename or press Enter to use latest file
    
    # Or specify a file:
    python valuation_from_csv.py
    # Enter: nse_single_date_NIFTY_07_Aug_2025_20250812_165341.csv

Dependencies:
- pandas: For CSV processing and data manipulation
- numpy: For numerical operations
- utils: For financial calculations (Black-Scholes, Greeks, valuation)
- datetime: For timestamp handling
- os, sys: For file operations and system integration
- glob: For file pattern matching

This script bridges the gap between raw data collection (nse_scraper.py) and
comprehensive analysis, providing professional-grade options valuation capabilities.

Author: NSE Options Analysis Project
License: See LICENSE file
"""

import pandas as pd
import numpy as np
from utils import black_scholes_greeks, black_scholes_price, option_valuation
from datetime import datetime
import sys
import os
import glob

OUTPUT_CSV_DIR = os.path.join('outputs', 'csv')

def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def find_latest_csv() -> str:
    candidates = sorted(glob.glob(os.path.join(OUTPUT_CSV_DIR, "*.csv")), key=os.path.getmtime, reverse=True)
    if not candidates:
        candidates = sorted(glob.glob("*.csv"), key=os.path.getmtime, reverse=True)
    return candidates[0] if candidates else ""

def calculate_greeks_and_valuation(row, r=0.063):
    """
    Calculate Greeks and valuation for a single option row.
    Uses Indian risk-free rate of 6.3% by default.
    """
    try:
        # Extract data from row
        S = row['Spot']
        K = row['Strike']
        T = row['T_years']
        sigma = row['IV'] / 100  # Convert percentage to decimal
        market_price = row['LTP']
        option_type = row['Type']
        bid = row['Bid']
        ask = row['Ask']
        
        # Skip if invalid data
        if T <= 0 or sigma <= 0 or market_price <= 0:
            return None, None, None, None
        
        # Calculate Greeks
        greeks = black_scholes_greeks(S, K, T, r, sigma, option_type)
        
        # Calculate theoretical price
        theoretical_price = black_scholes_price(S, K, T, r, sigma, option_type)
        
        # Perform valuation
        rating, pct_diff, confidence = option_valuation(
            theoretical_price, market_price, S, K, T, sigma, bid, ask, option_type
        )
        
        return greeks, theoretical_price, rating, pct_diff, confidence
        
    except Exception as e:
        print(f"Error processing row: {e}")
        return None, None, None, None, None

def main():
    # Get CSV filename from user
    print("If you press Enter, the latest CSV from outputs/csv will be used.")
    csv_file = input("Enter CSV filename from nse_scraper.py: ").strip()
    if not csv_file:
        csv_file = find_latest_csv()
        if not csv_file:
            print("No CSV files found in outputs/csv or project root.")
            sys.exit(1)
        print(f"Using latest CSV: {csv_file}")
    
    try:
        # Read CSV file
        df = pd.read_csv(csv_file)
        print(f"Loaded {len(df)} options from {csv_file}")
        
        # Validate required columns
        required_cols = ['Ticker', 'Expiration', 'Strike', 'Type', 'LTP', 'IV', 'Bid', 'Ask', 'Spot', 'T_years']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            print(f"Missing required columns: {missing_cols}")
            sys.exit(1)
        
        # Process each option
        results = []
        processed = 0
        
        print("\nProcessing options...")
        for idx, row in df.iterrows():
            greeks, theo_price, rating, pct_diff, confidence = calculate_greeks_and_valuation(row)
            
            if greeks is not None:
                # Add results to row
                result_row = row.copy()
                result_row['Theoretical_Price'] = theo_price
                result_row['Valuation_Rating'] = rating
                result_row['Pct_Difference'] = pct_diff
                result_row['Confidence'] = confidence
                result_row['Delta'] = greeks['delta']
                result_row['Gamma'] = greeks['gamma']
                result_row['Theta'] = greeks['theta']
                result_row['Vega'] = greeks['vega']
                result_row['Rho'] = greeks['rho']
                
                results.append(result_row)
                processed += 1
                
                # Progress indicator
                if processed % 50 == 0:
                    print(f"Processed {processed} options...")
        
        if not results:
            print("No valid options found for analysis")
            sys.exit(1)
        
        # Create results DataFrame
        results_df = pd.DataFrame(results)
        
        # Sort by percentage difference (best undervalued first)
        results_df = results_df.sort_values('Pct_Difference', ascending=False)
        
        # Save full results into outputs/csv
        ensure_dir(OUTPUT_CSV_DIR)
        output_file = os.path.join(OUTPUT_CSV_DIR, f"valuation_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv")
        results_df.to_csv(output_file, index=False)
        
        # Display top 10 undervalued options
        print(f"\n{'='*80}")
        print("TOP 10 UNDERVALUED OPTIONS:")
        print(f"{'='*80}")
        
        top_10 = results_df.head(10)
        for idx, row in top_10.iterrows():
            print(f"\n{row['Ticker']} {row['Type'].upper()} {row['Strike']} expiring {row['Expiration']}")
            print(f"  Market: ${row['LTP']:.2f} | Theoretical: ${row['Theoretical_Price']:.2f}")
            print(f"  Valuation: {row['Valuation_Rating'].upper()} ({row['Pct_Difference']*100:+.1f}%)")
            print(f"  Confidence: {row['Confidence']:.1%} | IV: {row['IV']:.1f}%")
            print(f"  Greeks: Δ={row['Delta']:.3f}, Γ={row['Gamma']:.4f}, Θ={row['Theta']:.1f}")
        
        # Summary statistics
        print(f"\n{'='*80}")
        print("SUMMARY STATISTICS:")
        print(f"{'='*80}")
        
        undervalued = results_df[results_df['Pct_Difference'] > 0.05]  # >5% undervalued
        overvalued = results_df[results_df['Pct_Difference'] < -0.05]  # >5% overvalued
        fairly_priced = results_df[(results_df['Pct_Difference'] >= -0.05) & (results_df['Pct_Difference'] <= 0.05)]
        
        print(f"Total options analyzed: {len(results_df)}")
        print(f"Undervalued (>5%): {len(undervalued)} ({len(undervalued)/len(results_df)*100:.1f}%)")
        print(f"Overvalued (>5%): {len(overvalued)} ({len(overvalued)/len(results_df)*100:.1f}%)")
        print(f"Fairly priced (±5%): {len(fairly_priced)} ({len(fairly_priced)/len(results_df)*100:.1f}%)")
        
        if len(undervalued) > 0:
            print(f"\nBest undervalued: {undervalued.iloc[0]['Pct_Difference']*100:+.1f}%")
        if len(overvalued) > 0:
            print(f"Most overvalued: {overvalued.iloc[-1]['Pct_Difference']*100:+.1f}%")
        
        print(f"\nFull results saved to: {output_file}")
        
    except FileNotFoundError:
        print(f"File {csv_file} not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error processing file: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 